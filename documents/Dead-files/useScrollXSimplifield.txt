import { useEffect, useContext, useRef, useCallback } from "react";
import { CartContext } from "../@components/CartContext";

export function useScrollX() {
  const {
    advertisementsRef,
    categoriesRef,
    promotionsRef,
    limitAdvertisements,
    limitCategories,
    limitProductList,
    translateX1,
    translateX2,
    translateX3,
    setTranslateX1,
    setTranslateX2,
    setTranslateX3
  } = useContext(CartContext);

  // Refs agrupados
  const refs = [
    advertisementsRef,
    categoriesRef,
    promotionsRef
  ];

  // Estado interno de arraste
  const variablesRef = useRef(
    refs.map(() => ({
      arrastando: false,
      toc_ini: 0,
      time_touch: 0,
      velocidade: 0,
      animacao: null
    }))
  );

  const translateRefs = [
    useRef(translateX1),
    useRef(translateX2),
    useRef(translateX3)
  ];
  useEffect(() => {
    translateRefs[0].current = translateX1;
    translateRefs[1].current = translateX2;
    translateRefs[2].current = translateX3;
  }, [translateX1, translateX2, translateX3]);
  
  const setTranslates = [setTranslateX1, setTranslateX2, setTranslateX3];

  //array de limites
  const limitsTranslateRefs = [
    useRef(limitAdvertisements),
    useRef(limitCategories),
    useRef(limitProductList)
  ];

  useEffect(() => {
    limitsTranslateRefs[0].current = limitAdvertisements;
    limitsTranslateRefs[1].current = limitCategories;
    limitsTranslateRefs[2].current = limitProductList;
  }, [limitAdvertisements, limitCategories, limitProductList]);


  const iniciarArraste = useCallback((e, i) =>  {
    e.preventDefault();
    if (e.button !== 0) return;

    const variables = variablesRef.current[i];

    variables.arrastando = true;
    variables.toc_ini = e.clientX;
    variables.time_touch = Date.now();
    variables.arraste=0;
    if (variables.animacao) {
      cancelAnimationFrame(variables.animacao);
      variables.animacao = null;
    }
  }, []);
  
  const aoMover = useCallback((e, i) => {
    e.preventDefault();
    const variables = variablesRef.current[i];
    if (!variables.arrastando) return;
    const now = Date.now();
    const dt = Math.max(1, now - variables.time_touch);
    const x =  e.clientX;

    const deslocamento = x - variables.toc_ini;
    const velocidade = deslocamento / dt;
    variables.velocidade = velocidade;
    if(Math.abs(velocidade)>1.7){
        variables.velocidade = 1.7 * Math.sign(velocidade);
    }

    variables.time_touch = now;
    variables.toc_ini= x;

    //limites e setar
    let proximo = translateRefs[i].current + deslocamento;
    const max = limitsTranslateRefs[i].current;
    if (proximo < max) {
    proximo = max;
    variables.velocidade = 0;
    } else if (proximo > 0) {
    proximo = 0;
    variables.velocidade = 0;
    }
    setTranslates[i](proximo);
  }, []);

  const finalizarArraste = useCallback((e, i) => {
    const variables = variablesRef.current[i];

    if (!variables.arrastando) return;
    variables.arrastando = false;
  
    // Cancela animação anterior, se existir
    if (variables.animacao) {
    cancelAnimationFrame(variables.animacao);
    }

    const decel = () => {
    if (Math.abs(variables.velocidade) > 0.15) {
        variables.velocidade *= 0.95;
        let proximo = translateRefs[i].current + variables.velocidade * 16;

        const max = limitsTranslateRefs[i].current;

        if (proximo < max) {
            proximo = max;
            variables.velocidade = 0;
        } else if (proximo > 0) {
            proximo = 0;
            variables.velocidade = 0;
        }
        setTranslates[i](proximo);
        variables.animacao = requestAnimationFrame(decel);
        }
    };
    decel();

    variables.animacao=null;
  }, []);
  
  const listeners = useRef([[], [], []]);

  useEffect(() => {
    refs.forEach((refWrapper, i) => {
      const el = refWrapper?.current;
      if (!el) return;
  
      const start = e => iniciarArraste(e, i);
      const move = e => aoMover(e, i);
      const end = e => finalizarArraste(e, i);
  
      listeners.current[i] = [start, move, end];
  

      el.addEventListener('mousedown', start, { passive: false });
      el.addEventListener('mousemove', move, { passive: false });
      el.addEventListener('mouseup', end);
    });
  
    return () => {
      refs.forEach((refWrapper, i) => {
        const el = refWrapper?.current;
        if (!el || !listeners.current[i]) return;

        const [start, move, end] = listeners.current[i];

        el.removeEventListener('mousedown', start);
        el.removeEventListener('mousemove', move);
        el.removeEventListener('mouseup', end);
      });
    };
  }, []);
}