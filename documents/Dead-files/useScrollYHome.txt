//rolagem da pagina inicial com translate e rolagem padrão desligada

//variaveis usadas de CartContext
const [translateMain, setTranslateMain] = useState(0);
const [limitMain, setLimitMain] = useState(0);
const mainRef = useRef(null);
const SearchBarRef = useRef(null);

//calculo de limite do main
const calcLimit = useCallback(() => {
  if(mainRef.current){
    const heightWindow = window.innerHeight;
    const mainHeight = parseFloat(getComputedStyle(mainRef.current).height);
    const limit = heightWindow - mainHeight;
    setLimitMain(limit);
  }
},[mainRef, setLimitMain]);

//A barra de pesquisa tambem precisava ser movida

import { useEffect, useContext, useRef, useCallback } from "react";
import { CartContext } from "../components/CartContext";

export function useScrollYHome() {
  const {mainRef, limitMain, translateMain, setTranslateMain} = useContext(CartContext);

  // Estado interno de arraste
  const variablesRef = useRef({
    arrastando: false,
    toc_ini: 0,
    time_touch: 0,
    velocidade: 0,
    animacao: null
  });

  const translateMainRef = useRef(translateMain);
  const limitMainRef = useRef(limitMain);

  useEffect(() => {
    translateMainRef.current = translateMain;
    
  }, [translateMain]);

  useEffect(() => {
    limitMainRef.current = limitMain;
  }, [limitMain]);

  const pageRef = useRef({
    initialX: null,
    initialY: null,
    firstAngle: null,
    dragY: null,
    firstDiffX: null,
    firstDiffY: null,
  });

  const iniciarArraste = useCallback((e) =>  {
    // setIsDragging(false);
    e.preventDefault();
    //
    const page = pageRef.current;
    const variables = variablesRef.current;
    page.initialX = e.touches[0].clientX;
    page.initialY = e.touches[0].clientY;
    page.deltaY = 0;
    page.speed=0;
    page.dragY=null;
    //
    variables.arrastando = true;
    variables.toc_ini = page.initialY;
    variables.time_touch = Date.now();
    variables.arraste=0;
    if (variables.animacao) {
      cancelAnimationFrame(variables.animacao);
      variables.animacao = null;
    }
  }, []);
  
  const aoMover = useCallback((e) => {
    e.preventDefault();
    // setIsDragging(true);
    const variables = variablesRef.current;
    if (!variables.arrastando) return;
    const page = pageRef.current;
    const now = Date.now();
    const dt = Math.max(1, now - variables.time_touch);
    const x = e.touches[0].clientX;
    const y = e.touches[0].clientY;
    const dx = Math.abs(x - page.initialX);
    const dy = Math.abs(y - page.initialY);
    if (dx <= 4 && dy <= 4) return;

    if (page.firstDiffX === null && page.firstDiffY ===null) {
      page.firstDiffX = dx;
      page.firstDiffY = dy;
      page.firstAngle  = Math.atan2(dy, dx) * (180 / Math.PI);
      if(page.firstAngle > 45) {page.dragY=true};
    }

    if (page.dragY) {
      const deslocamento = 2*(y - variables.toc_ini);

      if (Math.abs(deslocamento) < 0.5) return;
      const velocidade = 2*(deslocamento / dt);
      variables.velocidade = velocidade;
      if(Math.abs(velocidade)>1.7){
        variables.velocidade = 1.7 * Math.sign(velocidade);
      }

      variables.time_touch = now;
      variables.toc_ini= y;
      page.initialX = x;
      page.initialY=y;
      let proximo = translateMainRef.current + deslocamento;
      if (proximo < limitMainRef.current) {
        proximo = limitMainRef.current;
        variables.velocidade = 0;
      }
      setTranslateMain(proximo);
    }
  }, []);

  const finalizarArraste = useCallback((e) => {
    const page = pageRef.current;
    const variables = variablesRef.current;
    if (page.dragY) {
      if (!variables.arrastando) return;
      variables.arrastando = false;
  
      // Cancela animação anterior, se existir
      if (variables.animacao) {
        cancelAnimationFrame(variables.animacao);
      }
  
      const decel = () => {
        if (Math.abs(variables.velocidade) > 0.1) {
          variables.velocidade *= 0.95;
          let proximo = translateMainRef.current + variables.velocidade * 16;
          
          if (proximo < limitMainRef.current) {
            proximo = limitMainRef.current;
            variables.velocidade = 0;
          } 
          if(proximo>140){
            proximo=0;
            setTimeout(() => {
              location.reload();
            }, 600);
          }
          else if (proximo > 0) {
            proximo = 0;
            variables.velocidade = 0;
          }
          setTranslateMain(proximo);
          variables.animacao = requestAnimationFrame(decel);
        }
        // else{setIsDragging(false);}
      };
      decel();
    }
 
    page.initialX = null
    page.initialY = null
    page.firstAngle = null
    page.firstDiffX = null
    page.firstDiffY = null
    page.dragY= null
    variables.animacao=null;
  }, []);
  
  const listeners = useRef([]);

 useEffect(() => {
    const el = mainRef?.current;
    if (!el) return;

    const start = e => iniciarArraste(e);
    const move = e => aoMover(e);
    const end = e => finalizarArraste(e);

    // Armazena os listeners para poder removê-los depois, se necessário
    listeners.current = [start, move, end];

    el.addEventListener('touchstart', start, { passive: false });
    el.addEventListener('touchmove', move, { passive: false });
    el.addEventListener('touchend', end);

    return () => {
        const [start, move, end] = listeners.current;

        el.removeEventListener('touchstart', start);
        el.removeEventListener('touchmove', move);
        el.removeEventListener('touchend', end);
    };
 }, []);
}