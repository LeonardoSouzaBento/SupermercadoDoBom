Como vc converteria essas funções a seguir para meu hook personalizado useScroll? As variaveis de limi estão na mesma ordem no meu useScroll. Eu ja coloquei translateX1, translateX2, translateX3 no estilo das divs pais.

//inicio de useScroll
import { useState, useContext } from "react";
import { CartContext } from "./Componentes/CartContext";

const {
limitAdvertisements, 
limitCategories, 
limitProductList, 
translateX1, 
translateX2, 
translateX3, 
setTranslateX1,
setTranslateX2,
setTranslateX3
} = useContext(CartContext);

const [advertisementsVariables, setAdvertisementsVariables] = useState({
    arraste: translateX1,
    limit: limitAdvertisements,
    toc_ini: 0,
    toc_ini2: 0,
    time_touch: 0,
    velocidade: 0,
    animacao: null,
    arrastando: false,
  });
  
  const [categoriesVariables, setCategoriesVariables] = useState({
    arraste: translateX2,
    limit: limitCategories,
    toc_ini: 0,
    toc_ini2: 0,
    time_touch: 0,
    velocidade: 0,
    animacao: null,
    arrastando: false,
  });
  
  const [productListVariables, setProductListVariables] = useState({
    arraste: translateX3,
    limit: limitProductList,
    toc_ini: 0,
    toc_ini2: 0,
    time_touch: 0,
    velocidade: 0,
    animacao: null,
    arrastando: false,
  });

  //para rolagem da pagina
let initialY = null;
let initialX = null;
let diffX=null;
let diffY=null;
let firstAngle = null;
let firstDiffX = null;
let firstDiffY = null;
let dragY= null;
let tempoDecorrido = 0;
let startTime = null; 
let speed = 0; 
let deltaY = null;
const minSpeed = 0.7;
const maxSpeed = 2.0;
const limiar = 4;
let arrastando2 = false;

// Fim useScroll

//inicio das funções
let limi = [
  { div: imgs_anun, arraste: meio, limite: fim_anun, toc_ini: 0, toc_ini2: 0, time_touch: 0, velocidade: 0, animacaoRolagem: null, arrastando: false
  },
  { div: secoes, arraste: 0, limite: fim_sections, toc_ini: 0, toc_ini2: 0, time_touch: 0, velocidade: 0, animacaoRolagem: null, arrastando: false },
  { div: promos, arraste: 0, limite: fim_promos, toc_ini: 0, toc_ini2: 0, time_touch: 0, velocidade: 0, animacaoRolagem: null, arrastando: false }
];

limi.forEach((el, index) => {
  el.div.addEventListener('touchstart', (e) => iniciarArraste(e, index),{ passive: false });
  el.div.addEventListener('mousedown', (e) => iniciarArraste(e, index),{ passive: false });
  el.div.addEventListener('touchmove', (e) => aoMover(e, index),{ passive: false });
  el.div.addEventListener('mousemove', (e) => aoMover(e, index),{ passive: false });
  el.div.addEventListener('touchend', (e) => finalizarArraste(e, index));
  el.div.addEventListener('mouseup', (e) => finalizarArraste(e, index));
});

//para rolagem da pagina
let initialY = null;
let initialX = null;
let diffX=null;
let diffY=null;
let firstAngle = null;
let firstDiffX = null;
let firstDiffY = null;
let dragY= null;
let tempoDecorrido = 0;
let startTime = null; 
let speed = 0; 
let deltaY = null;
const minSpeed = 0.7;
const maxSpeed = 2.0;
const limiar = 4;
let arrastando2 = false;

//Iniciar arraste
const iniciarArraste = (e, i) => {
  e.preventDefault();
  arrastando2 = false;
  if (e.type == "mousedown" && e.button !== 0) return;
  dragXglobal = false;
  const posicaoX = e.touches ? e.touches[0].clientX : e.clientX;
  //pagina
  initialY =  e.touches ? e.touches[0].clientY : e.clientY;
  initialX =  e.touches ? e.touches[0].clientX : e.clientX;
  speed = 0;
  deltaY = 0;
  startTime = Date.now();

  //divs
  limi[i].toc_ini = posicaoX - limi[i].arraste; //divs
  limi[i].time_touch = Date.now();
  limi[i].arrastando = true;
  if (limi[i].animacaoRolagem) {
    cancelAnimationFrame(limi[i].animacaoRolagem);
    limi[i].animacaoRolagem = null;
  }
};
// Movimento
const aoMover = (e, i) => {
  if(!limi[i].arrastando) return;
  dragXglobal = true;
  const tempoAtual = Date.now();
  tempoDecorrido = Math.max(1, tempoAtual - limi[i].time_touch);

  const posicaoX = e.touches ? (e.touches[0] ? e.touches[0].clientX : null) : e.clientX;
  const currentY = e.touches ? (e.touches[0] ? e.touches[0].clientY : null) : e.clientY;

  if (posicaoX === null || currentY === null) return;
  diffX = Math.abs(posicaoX - initialX);
  diffY = Math.abs(currentY - initialY);

  // Limiar para ignorar movimentos muito pequenos
  if (diffX <= limiar && diffY <= limiar) return;
  arrastando2 = true;
  if (firstDiffX === null && firstDiffY === null) {
    firstDiffX = diffX;
    firstDiffY = diffY;
    firstAngle = Math.atan2(diffY, diffX) * (180 / Math.PI);
    if (firstAngle === null) firstAngle = 0;
  }
  //divs
  if (firstAngle < 45) {
    dragY= false;
    if (tempoDecorrido > 0) {
      limi[i].velocidade = (posicaoX - limi[i].toc_ini2) / tempoDecorrido; // px/ms
    }
    limi[i].time_touch = tempoAtual;
    limi[i].toc_ini2 = posicaoX;
    limi[i].arraste = posicaoX - limi[i].toc_ini;
    aplicarLimites(i);
    limi[i].div.style.transform = `translateX(${limi[i].arraste}px)`;

    initialX = posicaoX;
  }
  //pagina
  if(firstAngle > 60 && window.innerWidth < 993){
    deltaY = currentY - initialY;
    if (tempoDecorrido > 0) {
      speed = deltaY / tempoDecorrido;
      speed = Math.sign(speed) * Math.max(minSpeed, Math.min(Math.abs(speed), maxSpeed));
    }
    window.scrollBy(0, -deltaY);
    initialY = currentY;
    startTime = tempoAtual;
    dragY = true;
  }
  else{dragY=null};
};

// Finalizar arraste e iniciar desaceleração
const finalizarArraste = (e, i) => {
  if(!dragY){
    if (!limi[i].arrastando) return;
    limi[i].arrastando = false;
    const desacelerar = () => {
      if (Math.abs(limi[i].velocidade) > 0.01) { // Valor mínimo para parar
        limi[i].velocidade *= 0.95; // Reduz gradualmente a velocidade
        limi[i].arraste += limi[i].velocidade * 16; // Multiplica pela estimativa de 16ms/frame
        // Aplicar limites corretamente
        aplicarLimites(i);
        limi[i].div.style.transform = `translateX(${limi[i].arraste}px)`;
        if (Math.abs(limi[i].velocidade && e.currentTarget==imgs_anun) < 0.7) {atualizarPaginacao();}
        limi[i].animacaoRolagem = requestAnimationFrame(desacelerar);
      } else {
        limi[i].animacaoRolagem = null;
        if (e.currentTarget==imgs_anun) {atualizarPaginacao();}
      }
    };
    desacelerar();
  }
  
  if (dragY) {
    if (Math.abs(speed) < minSpeed) {
      speed = minSpeed * Math.sign(speed); // Garante movimento mínimo
    }

    if (!Number.isFinite(speed)) speed = minSpeed * Math.sign(deltaY);
    
    startMomentumScroll();
  }

  initialY = null; initialX = null; 
  firstAngle = null; firstDiffX = null; 
  firstDiffY = null;
  dragY=null;
};

function startMomentumScroll() {
  const decay = 0.95;
  const step = () => {
    if (Math.abs(speed) > 0.1) {
      speed *= decay;
      window.scrollBy(0, -speed * 16);
      requestAnimationFrame(step);
    }
    //removi o else daqui
  };
  requestAnimationFrame(step);
}
// Função para aplicar limites
const aplicarLimites = (i) => {
  if (limi[i].arraste < limi[i].limite) {
    limi[i].arraste = limi[i].limite;
    limi[i].velocidade = 0;
  }
  if (limi[i].arraste > 0) {
    limi[i].arraste = 0;
    limi[i].velocidade = 0;
  }
};
//fim das funções

//os componentes para aplicar as fuções
(advertisementsRef)
...
  return (
    <Div ref={divRef}>
      <P>Temos novidades!</P>
      <Advertisements ref={advertisementsRef} $translateValue={translateX1}>
        {imageUrls.map((url, index) => (
          <Fundo key={index} $bg={url} ref={(el) => (fundoRefs.current[index] = el)
          }>
            <Img src={url} alt={`Imagem de anúncio ${index + 1}`} id={`anun ${index + 1}`} />
          </Fundo>
        ))}
      </Advertisements>
      <Pagination>
        {imageUrls.map((_, i) => (
          <Span key={i} $atual={indicesCentrais.includes(i)}></Span>
        ))}
      </Pagination>
    </Div>
  );
}
export default AnnouncementSection;

(DivfRef)
...
  return (
    <Div ref={DivRef}>
      <Span className="material-symbols-outlined">swipe_left</Span>{/*Para tutorial de como usar a tela*/}
      <Divf ref={DivfRef} $translateValue={translateX2}>
        {category.map((cat, index) => (
          <CategoryItem 
            ref={index === 0 ? CategoryItemRef : null}
            category={cat}  
            key={cat.id} onClick={() => handleCategoryClick(cat.id)}
            isSelected={cat.id === selectedCategoryId}/>
        ))}
      </Divf>
    </Div>
  );
}
export default CategorySection;

(productListRef)
...
  return (
    <PaiAllProductsStyled ref={paiAllProductsRef}>
      <ProductListHome variant={'home'} categoryKey={categoryKey} ref={productListRef} $translateValue={translateX3}></ProductListHome>
    </PaiAllProductsStyled>
  );
}

export default PromoSection;


