  //alteração do overflow se for mobile
  const isTouchDevice = () => 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    // Se o desktop estiver com tela reduzida pela aba dev
    const handleScrollAttempt = () => {
      if (window.innerWidth <= 992 && document.body.style.overflow === 'hidden') {
        document.documentElement.style.overflow = 'auto';
        document.body.style.overflow = 'auto';
        window.removeEventListener('wheel', handleScrollAttempt);
      }
    };

    calcLimit();
    if(window.innerWidth <= 992 && isTouchDevice()){
      document.documentElement.style.overflow = 'hidden';
      document.body.style.overflow = 'hidden';
      window.addEventListener('wheel', handleScrollAttempt);
    } else {
      document.documentElement.style.overflow = 'auto';
      document.body.style.overflow = 'auto';
    }



// const handleResize = useCallback(() => {
//   let timeoutId;
//   return () => {
//     clearTimeout(timeoutId);
//     timeoutId = setTimeout(calcLimit, 300);
//   };
// }, [calcLimit]);

// useEffect(() => {
//   calcLimit();
// }, [calcLimit])

// useEffect(() => {
//   const debouncedResizeHandler = handleResize();
//   window.addEventListener('resize', debouncedResizeHandler);

//   return () => {
//     window.removeEventListener('resize', debouncedResizeHandler);
//   };
// }, [handleResize]);

removido de categorias:

useEffect(() => {
  let resizeTimeoutId = null;

  updateLimitCategories();

  const handleResize = () => {
    if (resizeTimeoutId) {
      clearTimeout(resizeTimeoutId);
    }
    resizeTimeoutId = setTimeout(() => {
      updateLimitCategories();
      resizeTimeoutId = null;
    }, 300); // Debounce: executa somente após 300ms da última redimensionada
  };

  window.addEventListener('resize', handleResize);

  return () => {
    window.removeEventListener('resize', handleResize);
    if (resizeTimeoutId) {
      clearTimeout(resizeTimeoutId);
    }
  };
}, [category.length, setLimitCategories]);

